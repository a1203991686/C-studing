#4.16 ~ 4.22 周报——田伟康
[TOC]

-------
##本周学习内容
###1.南阳oj完成了14题
>通过写南阳oj我发现了很多问题
>>**1.算法不够好**
很多时候同样一道题，我的代码很长，而且使用循环过多，而我看到其他同学提交的往往二十多行就解决了。
>>**2.WrongAnswer问题**
以前我觉得WrongAnswer是网站的问题，可是后来我才发现，WrongAnswer真的是我自己的问题，网站在测试程序时，它使用的数据是另外给出的，而不是题目上给出的例子，每次我都是看例子运行是否正确，而没考虑过有没有特殊情况。

下周开始针对以上两种情况进行改进
###2.继续学习链表
上周学习了链表的基础知识，这周继续学习链表，知道了创建、前插、后插、删除、更改
* **创建**
创建一个结构体，前几个成员是需要的数组内容，最后一个成员是指向下一个节点的指针next。

```c
#include"stdio.h"
#include"stdlib.h"
struct node
{
    int data;
    struct node *next;
}; //创建链表
int main()
{
    struct node *head, *p, *q, *t;
    int i, n, a;
    scanf("%d", &n);
    head = NULL;
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a);
        p = (struct node *)malloc(sizeof(struct node));
        p->data = a;
        p->next = NULL;
        if(head==NULL)
            head = p;
        else
        {
            q->next = p;
        }
        q = p;
    }
}
```
* **前插**
在链表头指针后面插入一个新的节点
```c
scanf("%d", &a);
p = (struct node *)malloc(sizeof(struct node));
p->next = head;
p->data = a;
head = p;
```
* **后插**
在链表尾节点之前创建一个新的节点
```c
scanf("%d", &a);
p = (struct node *)malloc(sizeof(struct node));
p->data = a;
q->next = NULL;
q->next = p;
p->next = NULL;
```
* **删除**
找到对应的节点，然后直接让这个节点的前一个节点的next=这个节点的next，然后再free这块节点
```c
int del;
struct node *pTemp, *pPre;
printf("请输入需要删除的位置:\n");
scanf("%d", &del);
pTemp = head;
pPre = pTemp;
for (i = 1; i < del; i++)
{
    pPre = pTemp;
    pTemp = pTemp->next;    
}
pPre->next = pTemp->next;
free(pTemp);
```
* **循环链表**
单链表的结尾是一个指向NULL的指针，而循环链表则是结尾指向了头指针。
##下周学习内容
* 继续学习双向链表知道把C语言课本中的链表知识学完
* 初步了解文件
* 开始写管理系统
* 继续写南阳oj
* 在CSDN上写一篇教学向博客
